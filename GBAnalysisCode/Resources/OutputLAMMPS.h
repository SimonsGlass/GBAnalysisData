#ifndef OUTPUT_LAMMPS

#define OUTPUT_LAMMPS

#include "../Resources/std_include.h"
#include "../State/StaticState.h"

//#define TASDEBUG

namespace LiuJamming
{

template <int dim>
bool OutputLAMMPS(string Filename, CStaticState<dim> &State)
{
	//Open the output file
	ofstream Output_File(Filename.c_str());
	Output_File.precision(15);

	if(!Output_File.is_open())
		return false;

	//Assumes that there are exactly two kinds of atoms.
	Eigen::VectorXd Radii;
	State.GetRadii(Radii);
	
	Eigen::VectorXd Positions;
	State.GetPositions(Positions);

	//Output the preamble
	Output_File << "State file generated by DSuss & SDog. Potential name: " << State.GetPotential()->DataToString() << endl << endl;

	Output_File << "\t" << State.GetParticleNumber() << " atoms\n";
	Output_File << "\t2 atom types\n";
	
	Eigen::Matrix<double,dim,dim> Transformation;
	State.GetBox()->GetTransformation(Transformation);
	Output_File << " 0.0 " << Transformation(0,0) << " xlo xhi\n";
	Output_File << " 0.0 " << Transformation(1,1) << " ylo yhi\n";
	Output_File << " 0.0 " << (dim > 2 ? Transformation(2,2) : 0.5) << " zlo zhi\n";

	//Output the atoms
	Output_File << "Atoms\n\n";

	for(int i = 0 ; i < State.GetParticleNumber() ; i++)
		Output_File << "\t" << i+1 << "\t" << (abs(Radii(i) - Radii(0))<0.001 ? 1 : 2) << "\t" << Positions(dim*i) << "\t" << Positions(dim*i+1) << "\t" << (dim>2 ? Positions(dim*i+2) : 0.25) << endl;

	Output_File.close();  

	return true;
}

template <int dim>
bool InputLAMMPS(string Filename, CStaticState<dim> &State)
{
	//Open the input file
	ifstream Input_File(Filename.c_str());
	
	if(!Input_File.is_open())
		return false;

	char line[256];
	Input_File.getline(line,256);
	Input_File.getline(line,256);

	//Read the number of particles
	int N;
	string tmp_str;
	int tmp_int; 
	Input_File >> N >> tmp_str;
	Input_File >> tmp_int >> tmp_str >> tmp_str;
	
	State.ClearSystem(N);	
	
	Input_File.getline(line,256);
	
	double sx,sy,sz,tmp_dbl;
	Input_File >> tmp_dbl >> sx >> tmp_str >> tmp_str;
	Input_File >> tmp_dbl >> sy >> tmp_str >> tmp_str;
	Input_File >> tmp_dbl >> sz >> tmp_str >> tmp_str;

	cout << "Read box size: " << sx << " : " << sy << " : " << sz << endl;

	if(dim==2){
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
                Trans(0,0) = sx;
                Trans(1,1) = sy;
                State.GetBox()->SetTransformation(Trans);
	}else{
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
		Trans(0,0) = sx;
		Trans(1,1) = sy;
		Trans(2,2) = sz;
		State.GetBox()->SetTransformation(Trans);
	}

        int nheader=14
	for(int iline = 0 ; iline < nheader ; iline++){
		Input_File.getline(line,256);
                if (iline == 3) cout << "Dump file line 3 says " << line << ", should be Natoms" << endl;
        }
	
        Eigen::VectorXd Positions(dim*N);
	Eigen::VectorXd Radii(N);	

#ifdef TASDEBUG
        cout << "Reading particles.\n";
	cout << "Number of particles: " << State.GetParticleNumber() << endl;
#endif        

	for(int i = 0 ; i < N ; i++)
	{
		int index,type,tmp;
		double x,y,z;

		Input_File >> index >> type >> x >> y >> z >> tmp >> tmp >> tmp;
                cout << "Read particle " << index << " at " << x << " : " << y << " : " << z << endl;

		index--;

		Positions(index*dim) = x;
		Positions(index*dim+1) = y;
		if(dim == 3)
			Positions(index*dim+2) = z;

		Radii(index) = type == 1 ? 0.44 : 0.5;

		
	}	
        cout << "Setting particle radius to 0.44 or 0.5 based on type.\n"; // TAS 

	State.SetPositions(Positions);
	State.SetRadii(Radii);
	
	State.SetPotentialLJ(1.0);
	return true;
}


template <int dim>
bool InputLAMMPS_Dump(string Filename, CStaticState<dim> &State)
{
	//Open the input file
	ifstream Input_File(Filename.c_str());
#ifdef TASDEBUG
        cout << "opened " << Filename << endl;
#endif        

	if(!(Input_File.is_open() && Input_File.good())) {
                cerr << "Was not able to open " << Filename ;
		return false;
        }

	char line[256];
	
	Input_File.getline(line,256);
	Input_File.getline(line,256);
	Input_File.getline(line,256);

	//Read the number of particles
	int N;
	string tmp_str;
        int cnafield;
	int tmp_int; 
	Input_File >> N;
#ifdef TASDEBUG
        cout << N << "is the number of particles in the top of dump file " << endl;
#endif        

	Input_File.getline(line,256);
	
	State.ClearSystem(N);	
	
	Input_File.getline(line,256);
	
	double sx,sy,sz,tmp_dbl;
        double minx,miny,minz;
	Input_File >> minx >> sx;
	Input_File >> miny >> sy;
	Input_File >> minz >> sz;

        // TAS 8/19/2016 I could reference all to the min values, assuming othorgonal box
        //sx = sx - minx;
        //sy = sy - miny;
        //sz = sz - minz;
#ifdef TASDEBUG
        cout << "Read box size: " << sx << " : " << sy << " : " << sz << endl;
#endif        

        // TAS subtract the minx,y,z to shift LAMMPS box origin to zero before learning the transformation
	if(dim==2){
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
                Trans(0,0) = sx - minx;
                Trans(1,1) = sy - miny;
                State.GetBox()->SetTransformation(Trans);
	}else{
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
		Trans(0,0) = sx - minx;
		Trans(1,1) = sy - miny;
		Trans(2,2) = sz - minz;
		State.GetBox()->SetTransformation(Trans);
	}

	Input_File.getline(line,256);

        // Next line of LAMMPS dump describes what fields are actually there.  We recognize several styles.
        int lmpdumpstyle = -1;
        char actualfields[256];
	Input_File.getline(actualfields,256);
        string dumpfieldsscaled("ITEM: ATOMS id xs ys zs"); // style 0
        string dumpfieldscna("ITEM: ATOMS id x y z StructureType"); // style 1
        string dumpfieldsall("ITEM: ATOMS id xs ys zs xu yu zu c_csym c_free_energy c_sigma[1] c_sigma[2] c_sigma[3] c_sigma[4] c_sigma[5] c_sigma[6] c_cna "); //style 2
        if (0 == dumpfieldsscaled.compare(actualfields)) {lmpdumpstyle=0;}
        if (0 == dumpfieldscna.compare(actualfields)) {lmpdumpstyle=1;}
        if (0 == dumpfieldsall.compare(actualfields)) {lmpdumpstyle=2;}
        if (lmpdumpstyle < 0) {
                cout << actualfields << endl;
                cout << "Dump does not have one of the styles of (expected fields)" << endl;
                return false;
        }



#ifdef TASDEBUG
	cout << "Reading particles.\n";
	cout << "Number of particles: " << State.GetParticleNumber() << endl;
        cout << "TAS Going to wrap particles to the box \n" << endl;
#endif        


	Eigen::VectorXd Positions(dim*N);
	Eigen::VectorXd Radii(N);	

        vector<int> Dumpcnafield(N);

	for(int i = 0 ; i < N ; i++)
	{
		int index,type,tmp,cnafield;
		double x,y,z;

                // For speed I may later move this logic out of the loop
		if (lmpdumpstyle == 1) {
                        Input_File >> index >> x >> y >> z >> cnafield;
                        // If not scaled coordinates, then scale them.
                        x/=sx; y/=sy; z/=sz;
                }
                else if (lmpdumpstyle == 2) {
                        double del1,del2,del3,del4,del5,del6,del7,del8,del9,del10,del11;
                        Input_File >> index >> x >> y >> z >> 
                                del1 >> del2 >> del3 >> 
                                del4 >> del5 >>
                                del6 >> del7 >> del8 >> del9 >> del10 >> del11 >>
                                cnafield;
                }
                else {
                        Input_File >> index >> x >> y >> z ;
                }

#ifdef TASDEBUG
                if (i % 500000 == 0) cout << i << "Read particle " << index << " at " << x << " : " << y << " : " << z << endl;
                if (i == 135) cout << i << " Read particle " << index << " at " << x << " : " << y << " : " << z << endl;
                if (i == 136) cout << i << " Read particle " << index << " at " << x << " : " << y << " : " << z << endl;
                if (i == 137) cout << i << " Read particle " << index << " at " << x << " : " << y << " : " << z << endl;
#endif                


		// TAS (**) Current version of the files are indexed from ID 1 so index--; is needed
                index--;

                // If positions are just outside the box, wrap them [0,1)
		if(x>=1.0) x-=1.0; if(x<0.0) x+=1.0; // if(x==1.0) x=0.0;
		if(y>=1.0) y-=1.0; if(y<0.0) y+=1.0; // if(y==1.0) y=0.0;
                if(dim==3) {if (z>=1.0) z-=1.0; if (z<0.0) z+=1.0;} // if(dim==3 && z == 1.0) z = 0.0;

                if ((index < 0) || index > N-1) printf("why is index out of bounds %i %i %f %f %f \n",i,index,x,y,z);
		Positions(index*dim) = x ;
		Positions(index*dim+1) = y;
		if(dim == 3)
			Positions(index*dim+2) = z;

		Radii(index) = 1.25; // TAS cc'd this \? statement since Ni is monatomic //  type == 1 ? 0.44 : 0.5;
        
                if (lmpdumpstyle == 1)
                        Dumpcnafield[index] = cnafield;
		
	}	
#ifdef TASDEBUG
        cout << "Read particles.\n";
#endif        
	Input_File.close();
	State.SetPositionsVirtual(Positions);
	State.SetRadii(Radii);
        if (lmpdumpstyle == 1) {
                State.SetCNAVirtual(Dumpcnafield,N);
                State.CNAisvalid = true;
        }
	
	State.SetPotentialLJ(1.0);
#ifdef TASDEBUG
        cout << "Returning from InputLAMMPS_Dump.\n";
#endif        

	return true;
}


template <int dim>
bool InputLAMMPS_Average(string Filename, CStaticState<dim> &State)
{
	//Open the input file
	ifstream Input_File(Filename.c_str());
	
	if(!Input_File.is_open())
		return false;

	char line[256];
	
	Input_File.getline(line,256);
	Input_File.getline(line,256);
	Input_File.getline(line,256);

	//Read the number of particles
	int N;
	string tmp_str;
	int tmp_int; 
	Input_File >> N;

	Input_File.getline(line,256);
	
	State.ClearSystem(N);	
	
	Input_File.getline(line,256);
	
	double sx,sy,sz,tmp_dbl;
	Input_File >> tmp_dbl >> sx;
	Input_File >> tmp_dbl >> sy;
	Input_File >> tmp_dbl >> sz;

	cout << "Read box size: " << sx << " : " << sy << " : " << sz << endl;

	if(dim==2){
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
                Trans(0,0) = sx;
                Trans(1,1) = sy;
                State.GetBox()->SetTransformation(Trans);
	}else{
		Eigen::Matrix<double,dim,dim> Trans = Eigen::Array<double,dim,dim>::Zero();
		Trans(0,0) = sx;
		Trans(1,1) = sy;
		Trans(2,2) = sz;
		State.GetBox()->SetTransformation(Trans);
	}

	Input_File.getline(line,256);
	Input_File.getline(line,256);
	
	Eigen::VectorXd Positions(dim*N);
	Eigen::VectorXd Radii(N);	

	cout << "Reading particles.\n";
	cout << "Number of particles: " << State.GetParticleNumber() << endl;

	for(int i = 0 ; i < N ; i++)
	{
		int index,type,tmp;
		double x,y,z;

		Input_File >> index >> type >> x >> y >> z;

//                cout << "Read particle " << index << " at " << x << " : " << y << " : " << z << endl;


		index--;
		
		//positions are in unwrapped coordinates, so wrap them
		while(x >= sx)
			x -= sx;

		while(x < 0)
			x += sx;

		while(y >= sy)
			y -= sy;
	
		while(y < 0)
			y += sy;

		if(dim==3)
		{
			while(z >= sz)
                        	z -= sz;

                	while(z < 0)
                        	z += sz;
		}

		Positions(index*dim) = x ;
		Positions(index*dim+1) = y;
		if(dim == 3)
			Positions(index*dim+2) = z;

		Radii(index) = type == 1 ? 0.44 : 0.5;

		
	}	
	Input_File.close();
	State.SetPositions(Positions);
	State.SetRadii(Radii);
	
	State.SetPotentialLJ(1.0);

	return true;
}

// Open a LAMMPS dump file and read in the ith column and the jth column
// The ith column are the integer IDs which become sorted
// The jth column of floating point numbers is returned as the DataArray
template <int dim>
bool LAMMPSDumpCol5_IDIndexed(string Filename, int numExpectedEntries, double* DataArray)
{
	//Open the input file
	ifstream Input_File(Filename.c_str());	
	if(!(Input_File.is_open() && Input_File.good())) {
                cerr << "Was not able to open " << Filename ;
		return false;
        }

	char line[256];
	int N, index, locallattice;
        double x,y,z;

	//Read the number of particles
        for (int iread = 0; iread < 3; iread++)
    	    Input_File.getline(line,256);
	Input_File >> N;
#ifdef TASDEBUG
        cout << N << "is the number of particles in the top of dump file " << endl;
#endif        
        if (N != numExpectedEntries) {printf("number of expected entries is not number said in file\n"); return -1;}

        // Skip the rest of the header
        for (int iread = 0; iread < 5; iread++)
	    Input_File.getline(line,256);
	
	cout << "Reading data column.\n";
	for(int i = 0 ; i < N ; i++)
	{
		Input_File >> index >> x >> y >> z >> locallattice;
		// ID's begin at 1 whereas indexing begins at 0
		DataArray(index-1) = locallattice;
	}	

	Input_File.close();
	cout << "Returning from InputLAMMPS_Dump.\n";

	return true;
}



}
#endif
